package thread_volatile;
/*
* volatile关键字的作用
* 1.原子性：不保证
* 2.可见性：保证
* 3.指令重排：禁止
*
* 测试多线程环境下，多个线程对共享变量的可见性
*   正常分析程序的执行逻辑：
*       回顾：多个线程对共享变量进行写操作的时候可能存在线程安全问题
*       程序中开启一个main线程和一个子线程
*       两个线程共享一个变量a，都可以修改共享变量
*       子线程围绕共享变量a是否等于0开启了一个while循环，当a改变时才能终止程序
*       现在main线程对a进行了写值
*
*       正常逻辑的结果是：
*       子线程先执行
*       main线程修改共享变量a的值，并在控制台输出a
*       子线程感应到a的值发生变化
*       退出循环，子线程运行结束
*       整个程序终止
*   实际的执行结果是：
*       main线程修改了a的值，并在控制台输出
*       子线程无法感应到共享变量的变化，无法退出while循环
*       注意：加了打印语句，会从主存中加载a同步到工作内存中，会导致子线程结束任务，无法达到预期的测试结果
*  问题发生的原因分析：
*       多线程之间对共享变量的变化是不可见的，每个线程把共享变量拿过来后复制一份会放在自己的工作内存中
*       在线程内对共享变量的操作也是对工作内存中的共享变量进行操作
*       如果运行期间存在另一个线程（main）对共享变量进行了修改
*       子线程是不可见的
*
*   解决多个线程之间共享变量不可见的问题
* volatile关键字修饰共享变量a 该变量在多个线程共同运行的环境下，如果其他线程中对中共享变量a进行了修改，子线程会立即感知到的
*
*
* */
public class Volatile_Demo {
//    private static int a=0;
    //使用volatile修饰共享变量a，多个线程对感应a的变化是可见的
    private static int a=0;

    public static void main(String[] args) {
        new Thread(new Runnable() {
            public void run() {
                while(a==0){
                    //加了打印语句，会从主存中加载a同步到工作内存中导致测试结果无法到达预期
//                    System.out.println(a);
                }
            }
        }).start();
        try {
            //main线程休眠1秒钟，以保证子线程先执行
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        a=1;
        //main线程执行完这条语句就结束,会将工作内存中的共享变量a更新到主存中
        System.out.println(a);
    }
}
